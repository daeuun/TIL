## **JVM**
![image](https://github.com/daeuun/TIL/assets/79685920/09716819-f135-42e3-bb10-2250ee524926)

`Java Virtual Machine`의 약자로, `자바 가상 머신` 

**자바를 실행하기 위한 가상 컴퓨터** (실제 컴퓨터가 아닌 소프트웨어로 구현된 컴퓨터)

java 바이트 코드를 실행할 수 있는 주체로,  
Source Code ```.java``` 파일을 Java Compiler를 통해서 Byte Code ```.class``` 파일로 변환한다. (컴퓨터가 이해할 수 있는 코드로 변환)

<br>

**자바와 운영체제 사이에서 중개자** 역할을 수행하며, 자바가 운영체제에 구애 받지 않고 프로그램을 실행할 수 있도록 도와준다. 

일반 애플리케이션 코드는 운영체제만 거치고 하드웨어로 전달되지만,  
자바는 JVM을 한번 더 거치고 → 운영체제로 전달되기 때문에 다른 OS에서도 코드 변경없이 실행이 가능하다!

자바의 핵심 철학은 ***Write once, run anywhere*** (작성은 한 번만, 돌리는 건 어디서든)이다.  
따라서 자바는 소스코드를 곧바로 기계어로 번역하지 않고, 바이트 코드라는 중간 언어를 만들어 내는 것이다.

즉, 자바는 플랫폼 독립적인 언어를 지향하고, JVM은 운영체제 위에서 동작하는 프로세스이다.  
자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 한다.

GC 가비지 컬렉터를 사용한 메모리 관리도 자동으로 수행하며, 다른 하드웨어와 다르게 레지스터 기반이 아닌 스택 기반으로 동작한다.

<br>

## **자바 프로그램의 실행 단계**
![Untitled (1)](https://user-images.githubusercontent.com/79685920/137158739-68e480d7-f067-4f4f-8cd4-669ed69088d0.png)


1. `자바 컴파일러`에 의해 **자바 소스 파일** → **바이트 코드로 변환**
2. 바이트 코드를 `JVM`에서 읽어 들인 다음에, 어떤 운영체제든간에 프로그램을 실행할 수 있도록 만들어 준다.
    
    만약, 자바 소스 파일은 리눅스에서 만들었고 윈도우에서 이 파일을 실행하고 싶다면? 
    
    윈도우용 JVM을 설치만 하면 된다! 따라서 JVM은 운영체제에 종속적이다.

<br>    

## **JVM 메모리 구조**

![Untitled (2)](https://user-images.githubusercontent.com/79685920/137158735-a1ce13e5-8b86-45cd-b652-00eb99b37982.png)

자바 소스 파일은 `자바 컴파일러`에 의해서 바이트 코드 형태인 **클래스 파일**이 된다. 

그리고 이 클래스 파일은 `클래스 로더`가 읽어들이면서 `JVM`이 수행된다.

1. **Class Loader**
    
    JVM 내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈
    
    자바는 런타임 시에 동적으로 클래스를 읽어오므로(동적 로드), 프로그램이 실행 중인 런타임(바이트 코드를 실행할 때)에서야 모든 코드가 자바 가상 머신과 연결된다.
    클래스 로더가 동적 로드를 담당한다.

    정리하자면, **클래스 로더는 런타임 중에 JVM의 메소드 영역에 동적으로 Java 클래스```.class```를 로드하는 역할을 한다.**
    
3. **Execution Engine**
    
    클래스 로더를 통해 JVM 내의 Runtime Data Area에 배치된 바이트 코드들을 명렁어 단위로 읽어서 실행하는 엔진이다.
    
    최초 JVM이 나왔을 당시에는 인터프리터 방식이었기때문에 속도가 느리다는 단점이 있었지만, JIT 컴파일러 방식을 통해 이 점을 보완하였다.  
    JIT는 바이트 코드를 어셈블러 같은 네이티브 코드로 바꿈으로써 실행이 빠르지만 역시 변환하는데 비용이 발생한다. 
    
    따라서 JVM은 모든 코드를 JIT 컴파일러 방식으로 실행하지 않고, ***인터프리터 방식을 사용하다가 일정한 기준이 넘어가면 JIT 컴파일러 방식으로 실행한다.***
    
5. **Garbage Collector**
    
    Garbage Collector(GC) 는 힙 메모리 영역에 생성된 객체들 중에서 참조되지 않은 객체들을 탐색 후 제거하는 역할을 한다. 이때, GC가 역할을 하는 시간은 언제인지 정확히 알 수 없다.
    
6. **Runtime Data Area**
    
   JVM이 프로그램을 수행하기위해 운영체제로부터 할당받은 메모리 공간이다.  
   자바 애플리케이션을 실행할 때 사용되는 데이터들을 적재하는 영역
    
    크게 Method Area, Heap Area, Stack Area, PC Register, Native Method Stack로 나눌 수 있다.
