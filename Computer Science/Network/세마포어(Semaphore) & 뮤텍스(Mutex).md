공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다.
이때 공유된 자원의 데이터는 **한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.**  

여러 프로세스나 쓰레드가 공유 자원에 접근하는 것을 제어하기 위한 방법  
⇒ 병행 처리를 위한 프로세스 동기화 기법

<br>

## 💡**임계 구역(Critical Section)**

: 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에,

한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

<br>


## 💡**세마포어(Semaphore)**

**공유된 자원의 데이터에 여러 Process 혹은 Thread**가 접근하는 것을 막아줌 

= 동기화 대상이 하나 이상

<br>

- Semaphore는 깃발이라는 뜻

기찻길에서 파란색 깃발이 걸려있으면 지나가도 되고, 빨간색 깃발이 걸려있으면 섰다가 다른 기차가 지나가면 지나가게했는데 이 깃발을 semaphore라고 부른다.

여기서 겹치는 기찻길 부분이 두 기차가 공유하는 critical section 

<br>

lock의 경우는, 0 또는 1

세마포어는 shared data의 개수를 의미한다.

그래서 0 or 1 or 2 or.. 등이 될 수 있다. 기찻길에서 공유자원이 한 개이므로 semaphore의 값은 0 또는 1이 된다. 이미 다른 기차가 지나가고 있으면 사용할 수 없으니 0이고, critical section이 비어있으면 1의 값을 가지게 된다. 

<br>

### 0 또는 1의 값만 갖는 세마포어  **binary semaphore**

Lock하고 작동 원리가 반대이다.

0하고 1이 왔다갔다 하는 것은 똑같지만, 

세마포어는 초기화가 1이고 사용하면 0인데, Lock은 사용했을 경우 1임!!

<br>

### **counting semaphore**

0과 1뿐만 아니라,2 ,3, 4 등의 값들 또한 가질 수 있는, 도메인이 제한 없는 세마포어

예를들어 서버에 프린터가 다섯 대가 물려있다. 사용자는 프린트를 사용하려고 서버에 요청한다. 

그러면 공유자원 즉 프린터가 5개가 있으니까 5로 설정이 되고, 프린터를 사용자가 사용할때마다 하나씩 감소한다. 그러다가 사용할 프린터가 없어지면 세마포어는 0이되고, 누군가가 프린터를 다 쓰고 반환하면 세마포어가 다시 1이 증가된다. 

<br>

- 세마포어는 단순히 변수로, 공유자원의 갯수를 나타내는 변수이다.

정수값을 가지는 변수 ⇒ 정수값은 접근할 수 있는 최대 허용치 만큼 동시에 사용자 접근을 할 수 있게 한다.

<br>

### **semaphore 접근함수**

자원을 사용하고 반납하는 함수

- **semWait 연산**: 세마포어 값을 감소시킨다. 만일 값이 음수가 되면 semWait를 호출한 프로세스는 블록됨. 음수가 아니면, 프로세스는 계속 수행될 수 있다.
- **semSignal 연산**: 세마포어 값을 증가시킨다. 만약 값이 양수가 아니면(0이거나 음수면), semWait 연산에 의해 블록된 프로세스들을 깨운다.

```c
struct semaphore {
	int count;
    	queueType queue;
};

void semWait (semaphore s) {
	s.count--;
    if (s.count < 0) {
    	/* 이 구역으로 들어왔다는 것은 현재 프로세스(혹은 쓰레드)가 공유 자원에 접근할 수 없다는 것을 의미*/
    	/* 요청한 프로세스를 s.queue에 연결 */
        /* 요청한 프로세스를 블록 상태로 전이 시킴*/
    }
}

void semSignal (semaphore s) {
	s.count++;
    if (s.count <= 0) {
    	/* count가 0보다 작거나 같다는 것은 대기하고 있는 프로세스(또는 스레드)가 존재한다는 것을 의미*/
        /* s.queue에 연결되어 있는 프로세스를 큐에서 제거 */
        /* 프로세스의 상태를 실행 가능으로 전이시키고 ready list에 연결 */
    }
}
```

세마포어는 위와 같이 되어 있고, 이것을 활용하면 다음과 같이 구현할 수 있다.

```c
const int n = /* 프로세스 개수 */;
semaphore s = 1;

void P (int i) {
	while (true) {
    	semWait(s);

        /* 임계 영역(Critical Section)*/

        semSignal(s);

        /* 임계 영역 이후 코드 */
    }
}

void main() {
	parbegin (P(1), P(2), ..., P(n));
```

<br>

## 💡**뮤텍스(Mutex)**

**공유된 자원의 데이터에 하나의 Process 혹은 Thread**가 접근하는 것을 막아줌

= 동기화 대상이 하나

<br>

### **동작 원리**

뮤텍스는 세마포어와 마찬가지로 병행 처리를 위한 동기화 기법 중 하나

이진 세마포어와 같이 초기값을 1과 0으로 가진다.

임계영역에 들어갈 때 락(lock)을 걸어 다른 프로세스(혹은 쓰레드)가 접근하지 못하도록 하고,

임계영역에서 나와 해당 락을 해제(unlock)한다.

<br>

## **뮤텍스와 세마포어의 차이?**

세마포어는 공유 자원에 **세마포어의 변수만큼의** Process 혹은 Thread가 접근 OK

반면에 뮤텍스는 **오직 1개만**의 Process 혹은 Thread만 접근 OK

현재 수행중인 프로세스가 아닌 다른 프로세스가 세마포어를 해제할 수 있지만,

뮤텍스는 락(lock)을 획득한 프로세스가 반드시 그 락을 해제해야 한다.